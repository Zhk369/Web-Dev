<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    let map = new Map();

    map.set('1', 'str1');   // a string key
    map.set(1, 'num1');     // a numeric key
    map.set(true, 'bool1'); // a boolean key

    // remember the regular Object? it would convert keys to string
    // Map keeps the type, so these two are different:
    alert( map.get(1)   ); // 'num1'
    alert( map.get('1') ); // 'str1'

    alert( map.size ); // 3

    let john = { name: "John" };
    let ben = { name: "Ben" };

    let visitsCountObj = {}; // try to use an object

    visitsCountObj[ben] = 234; // try to use ben object as the key
    visitsCountObj[john] = 123; // try to use john object as the key, ben object will get replaced

    // That's what got written!
    alert( visitsCountObj["[object Object]"] ); // 123

    let recipeMap = new Map([
        ['cucumber', 500],
        ['tomatoes', 350],
        ['onion',    50]
    ]);

    // iterate over keys (vegetables)
    for (let vegetable of recipeMap.keys()) {
        alert(vegetable); // cucumber, tomatoes, onion
    }

    // iterate over values (amounts)
    for (let amount of recipeMap.values()) {
        alert(amount); // 500, 350, 50
    }

    // iterate over [key, value] entries
    for (let entry of recipeMap) { // the same as of recipeMap.entries()
        alert(entry); // cucumber,500 (and so on)
    }

    map = new Map([
        ['1',  'str1'],
        [1,    'num1'],
        [true, 'bool1']
    ]);

    alert( map.get('1') ); // str1

    let map = new Map();
    map.set('banana', 1);
    map.set('orange', 2);
    map.set('meat', 4);

    let obj = Object.fromEntries(map.entries()); // make a plain object (*)

    // done!
    // obj = { banana: 1, orange: 2, meat: 4 }

    alert(obj.orange); // 2



    //SETS


    let set = new Set();

    let john= { name: "John" };
    let pete = { name: "Pete" };
    let mary = { name: "Mary" };

    // visits, some users come multiple times
    set.add(john);
    set.add(pete);
    set.add(mary);
    set.add(john);
    set.add(mary);

    // set keeps only unique values
    alert( set.size ); // 3

    for (let user of set) {
        alert(user.name); // John (then Pete and Mary)
    }

    set = new Set(["oranges", "apples", "bananas"]);

    for (let value of set) alert(value);

    // the same with forEach:
    set.forEach((value, valueAgain, set) => {
        alert(value);
    });

    let messages = [
        {text: "Hello", from: "John"},
        {text: "How goes?", from: "John"},
        {text: "See you soon", from: "Alice"}
    ];

    let readMessages = new WeakSet();

    // two messages have been read
    readMessages.add(messages[0]);
    readMessages.add(messages[1]);
    // readMessages has 2 elements

    // ...let's read the first message again!
    readMessages.add(messages[0]);
    // readMessages still has 2 unique elements

    // answer: was the message[0] read?
    alert("Read message 0: " + readMessages.has(messages[0])); // true

    messages.shift();
    // now readMessages has 1 element (technically memory may be cleaned later)

    let messages = [
        {text: "Hello", from: "John"},
        {text: "How goes?", from: "John"},
        {text: "See you soon", from: "Alice"}
    ];

    let readMap = new WeakMap();

    readMap.set(messages[0], new Date(2017, 1, 1));
    // Date object we'll study later

</script>
</body>
</html>